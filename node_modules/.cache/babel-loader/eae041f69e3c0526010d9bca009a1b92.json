{"ast":null,"code":"/*!\n * @pixi/canvas-graphics - v5.2.0\n * Compiled Wed, 06 Nov 2019 02:32:43 UTC\n *\n * @pixi/canvas-graphics is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { SHAPES, Matrix } from '@pixi/math';\nimport { Graphics } from '@pixi/graphics';\nimport { CanvasRenderer } from '@pixi/canvas-renderer';\nimport { RenderTexture, Texture } from '@pixi/core';\n/**\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original PixiJS version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they\n * now share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's CanvasGraphicsRenderer:\n * https://github.com/libgdx/libgdx/blob/1.0.0/gdx/src/com/badlogic/gdx/graphics/glutils/ShapeRenderer.java\n */\n\n/**\n * Renderer dedicated to drawing and batching graphics objects.\n *\n * @class\n * @protected\n * @memberof PIXI\n */\n\nvar CanvasGraphicsRenderer = function CanvasGraphicsRenderer(renderer) {\n  this.renderer = renderer;\n};\n/**\n * Renders a Graphics object to a canvas.\n *\n * @param {PIXI.Graphics} graphics - the actual graphics object to render\n */\n\n\nCanvasGraphicsRenderer.prototype.render = function render(graphics) {\n  var renderer = this.renderer;\n  var context = renderer.context;\n  var worldAlpha = graphics.worldAlpha;\n  var transform = graphics.transform.worldTransform;\n  var resolution = renderer.resolution;\n  context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, transform.tx * resolution, transform.ty * resolution); // update tint if graphics was dirty\n\n  if (graphics.canvasTintDirty !== graphics.geometry.dirty || graphics._prevTint !== graphics.tint) {\n    this.updateGraphicsTint(graphics);\n  }\n\n  renderer.setBlendMode(graphics.blendMode);\n  var graphicsData = graphics.geometry.graphicsData;\n\n  for (var i = 0; i < graphicsData.length; i++) {\n    var data = graphicsData[i];\n    var shape = data.shape;\n    var fillStyle = data.fillStyle;\n    var lineStyle = data.lineStyle;\n    var fillColor = data._fillTint;\n    var lineColor = data._lineTint;\n    context.lineWidth = lineStyle.width;\n\n    if (data.type === SHAPES.POLY) {\n      context.beginPath();\n      var points = shape.points;\n      var holes = data.holes;\n      var outerArea = void 0;\n      var innerArea = void 0;\n      var px = void 0;\n      var py = void 0;\n      context.moveTo(points[0], points[1]);\n\n      for (var j = 2; j < points.length; j += 2) {\n        context.lineTo(points[j], points[j + 1]);\n      }\n\n      if (shape.closeStroke) {\n        context.closePath();\n      }\n\n      if (holes.length > 0) {\n        outerArea = 0;\n        px = points[0];\n        py = points[1];\n\n        for (var j$1 = 2; j$1 + 2 < points.length; j$1 += 2) {\n          outerArea += (points[j$1] - px) * (points[j$1 + 3] - py) - (points[j$1 + 2] - px) * (points[j$1 + 1] - py);\n        }\n\n        for (var k = 0; k < holes.length; k++) {\n          points = holes[k].shape.points;\n\n          if (!points) {\n            continue;\n          }\n\n          innerArea = 0;\n          px = points[0];\n          py = points[1];\n\n          for (var j$2 = 2; j$2 + 2 < points.length; j$2 += 2) {\n            innerArea += (points[j$2] - px) * (points[j$2 + 3] - py) - (points[j$2 + 2] - px) * (points[j$2 + 1] - py);\n          }\n\n          if (innerArea * outerArea < 0) {\n            context.moveTo(points[0], points[1]);\n\n            for (var j$3 = 2; j$3 < points.length; j$3 += 2) {\n              context.lineTo(points[j$3], points[j$3 + 1]);\n            }\n          } else {\n            context.moveTo(points[points.length - 2], points[points.length - 1]);\n\n            for (var j$4 = points.length - 4; j$4 >= 0; j$4 -= 2) {\n              context.lineTo(points[j$4], points[j$4 + 1]);\n            }\n          }\n\n          if (holes[k].shape.closeStroke) {\n            context.closePath();\n          }\n        }\n      }\n\n      if (fillStyle.visible) {\n        context.globalAlpha = fillStyle.alpha * worldAlpha;\n        context.fillStyle = \"#\" + (\"00000\" + (fillColor | 0).toString(16)).substr(-6);\n        context.fill();\n      }\n\n      if (lineStyle.visible) {\n        context.globalAlpha = lineStyle.alpha * worldAlpha;\n        context.strokeStyle = \"#\" + (\"00000\" + (lineColor | 0).toString(16)).substr(-6);\n        context.stroke();\n      }\n    } else if (data.type === SHAPES.RECT) {\n      if (fillStyle.visible) {\n        context.globalAlpha = fillStyle.alpha * worldAlpha;\n        context.fillStyle = \"#\" + (\"00000\" + (fillColor | 0).toString(16)).substr(-6);\n        context.fillRect(shape.x, shape.y, shape.width, shape.height);\n      }\n\n      if (lineStyle.visible) {\n        context.globalAlpha = lineStyle.alpha * worldAlpha;\n        context.strokeStyle = \"#\" + (\"00000\" + (lineColor | 0).toString(16)).substr(-6);\n        context.strokeRect(shape.x, shape.y, shape.width, shape.height);\n      }\n    } else if (data.type === SHAPES.CIRC) {\n      // TODO - need to be Undefined!\n      context.beginPath();\n      context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);\n      context.closePath();\n\n      if (fillStyle.visible) {\n        context.globalAlpha = fillStyle.alpha * worldAlpha;\n        context.fillStyle = \"#\" + (\"00000\" + (fillColor | 0).toString(16)).substr(-6);\n        context.fill();\n      }\n\n      if (lineStyle.visible) {\n        context.globalAlpha = lineStyle.alpha * worldAlpha;\n        context.strokeStyle = \"#\" + (\"00000\" + (lineColor | 0).toString(16)).substr(-6);\n        context.stroke();\n      }\n    } else if (data.type === SHAPES.ELIP) {\n      // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\n      var w = shape.width * 2;\n      var h = shape.height * 2;\n      var x = shape.x - w / 2;\n      var y = shape.y - h / 2;\n      context.beginPath();\n      var kappa = 0.5522848;\n      var ox = w / 2 * kappa; // control point offset horizontal\n\n      var oy = h / 2 * kappa; // control point offset vertical\n\n      var xe = x + w; // x-end\n\n      var ye = y + h; // y-end\n\n      var xm = x + w / 2; // x-middle\n\n      var ym = y + h / 2; // y-middle\n\n      context.moveTo(x, ym);\n      context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n      context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n      context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n      context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n      context.closePath();\n\n      if (fillStyle.visible) {\n        context.globalAlpha = fillStyle.alpha * worldAlpha;\n        context.fillStyle = \"#\" + (\"00000\" + (fillColor | 0).toString(16)).substr(-6);\n        context.fill();\n      }\n\n      if (lineStyle.visible) {\n        context.globalAlpha = lineStyle.alpha * worldAlpha;\n        context.strokeStyle = \"#\" + (\"00000\" + (lineColor | 0).toString(16)).substr(-6);\n        context.stroke();\n      }\n    } else if (data.type === SHAPES.RREC) {\n      var rx = shape.x;\n      var ry = shape.y;\n      var width = shape.width;\n      var height = shape.height;\n      var radius = shape.radius;\n      var maxRadius = Math.min(width, height) / 2 | 0;\n      radius = radius > maxRadius ? maxRadius : radius;\n      context.beginPath();\n      context.moveTo(rx, ry + radius);\n      context.lineTo(rx, ry + height - radius);\n      context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);\n      context.lineTo(rx + width - radius, ry + height);\n      context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);\n      context.lineTo(rx + width, ry + radius);\n      context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);\n      context.lineTo(rx + radius, ry);\n      context.quadraticCurveTo(rx, ry, rx, ry + radius);\n      context.closePath();\n\n      if (fillStyle.visible) {\n        context.globalAlpha = fillStyle.alpha * worldAlpha;\n        context.fillStyle = \"#\" + (\"00000\" + (fillColor | 0).toString(16)).substr(-6);\n        context.fill();\n      }\n\n      if (lineStyle.visible) {\n        context.globalAlpha = lineStyle.alpha * worldAlpha;\n        context.strokeStyle = \"#\" + (\"00000\" + (lineColor | 0).toString(16)).substr(-6);\n        context.stroke();\n      }\n    }\n  }\n};\n/**\n * Updates the tint of a graphics object\n *\n * @protected\n * @param {PIXI.Graphics} graphics - the graphics that will have its tint updated\n */\n\n\nCanvasGraphicsRenderer.prototype.updateGraphicsTint = function updateGraphicsTint(graphics) {\n  graphics._prevTint = graphics.tint;\n  graphics.canvasTintDirty = graphics.geometry.dirty;\n  var tintR = (graphics.tint >> 16 & 0xFF) / 255;\n  var tintG = (graphics.tint >> 8 & 0xFF) / 255;\n  var tintB = (graphics.tint & 0xFF) / 255;\n  var graphicsData = graphics.geometry.graphicsData;\n\n  for (var i = 0; i < graphicsData.length; ++i) {\n    var data = graphicsData[i];\n    var fillColor = data.fillStyle.color | 0;\n    var lineColor = data.lineStyle.color | 0; // super inline, cos optimization :)\n\n    data._fillTint = ((fillColor >> 16 & 0xFF) / 255 * tintR * 255 << 16) + ((fillColor >> 8 & 0xFF) / 255 * tintG * 255 << 8) + (fillColor & 0xFF) / 255 * tintB * 255;\n    data._lineTint = ((lineColor >> 16 & 0xFF) / 255 * tintR * 255 << 16) + ((lineColor >> 8 & 0xFF) / 255 * tintG * 255 << 8) + (lineColor & 0xFF) / 255 * tintB * 255;\n  }\n};\n/**\n * destroy graphics object\n *\n */\n\n\nCanvasGraphicsRenderer.prototype.destroy = function destroy() {\n  this.renderer = null;\n};\n\nvar canvasRenderer;\nvar tempMatrix = new Matrix();\n/**\n * Generates a canvas texture. Only available with **pixi.js-legacy** bundle\n * or the **@pixi/canvas-graphics** package.\n * @method generateCanvasTexture\n * @memberof PIXI.Graphics#\n * @param {number} scaleMode - The scale mode of the texture.\n * @param {number} resolution - The resolution of the texture.\n * @return {PIXI.Texture} The new texture.\n */\n\nGraphics.prototype.generateCanvasTexture = function generateCanvasTexture(scaleMode, resolution) {\n  if (resolution === void 0) resolution = 1;\n  var bounds = this.getLocalBounds();\n  var canvasBuffer = RenderTexture.create(bounds.width, bounds.height, scaleMode, resolution);\n\n  if (!canvasRenderer) {\n    canvasRenderer = new CanvasRenderer();\n  }\n\n  this.transform.updateLocalTransform();\n  this.transform.localTransform.copyTo(tempMatrix);\n  tempMatrix.invert();\n  tempMatrix.tx -= bounds.x;\n  tempMatrix.ty -= bounds.y;\n  canvasRenderer.render(this, canvasBuffer, true, tempMatrix);\n  var texture = Texture.from(canvasBuffer.baseTexture._canvasRenderTarget.canvas, {\n    scaleMode: scaleMode\n  });\n  texture.baseTexture.resolution = resolution;\n  texture.baseTexture.update();\n  return texture;\n};\n\nGraphics.prototype.cachedGraphicsData = [];\n/**\n * Renders the object using the Canvas renderer\n *\n * @method _renderCanvas\n * @memberof PIXI.Graphics#\n * @private\n * @param {PIXI.CanvasRenderer} renderer - The renderer\n */\n\nGraphics.prototype._renderCanvas = function _renderCanvas(renderer) {\n  if (this.isMask === true) {\n    return;\n  }\n\n  this.finishPoly();\n  renderer.plugins.graphics.render(this);\n};\n\nexport { CanvasGraphicsRenderer };","map":{"version":3,"sources":["../src/CanvasGraphicsRenderer.js","../src/Graphics.js"],"names":["const","let","j"],"mappings":"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","sourcesContent":["import { SHAPES } from '@pixi/math';\n\n/**\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original PixiJS version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they\n * now share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's CanvasGraphicsRenderer:\n * https://github.com/libgdx/libgdx/blob/1.0.0/gdx/src/com/badlogic/gdx/graphics/glutils/ShapeRenderer.java\n */\n\n/**\n * Renderer dedicated to drawing and batching graphics objects.\n *\n * @class\n * @protected\n * @memberof PIXI\n */\nexport class CanvasGraphicsRenderer\n{\n    /**\n     * @param {PIXI.CanvasRenderer} renderer - The current PIXI renderer.\n     */\n    constructor(renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * Renders a Graphics object to a canvas.\n     *\n     * @param {PIXI.Graphics} graphics - the actual graphics object to render\n     */\n    render(graphics)\n    {\n        const renderer = this.renderer;\n        const context = renderer.context;\n        const worldAlpha = graphics.worldAlpha;\n        const transform = graphics.transform.worldTransform;\n        const resolution = renderer.resolution;\n\n        context.setTransform(\n            transform.a * resolution,\n            transform.b * resolution,\n            transform.c * resolution,\n            transform.d * resolution,\n            transform.tx * resolution,\n            transform.ty * resolution\n        );\n\n        // update tint if graphics was dirty\n        if (graphics.canvasTintDirty !== graphics.geometry.dirty\n            || graphics._prevTint !== graphics.tint)\n        {\n            this.updateGraphicsTint(graphics);\n        }\n\n        renderer.setBlendMode(graphics.blendMode);\n\n        const graphicsData = graphics.geometry.graphicsData;\n\n        for (let i = 0; i < graphicsData.length; i++)\n        {\n            const data = graphicsData[i];\n            const shape = data.shape;\n            const fillStyle = data.fillStyle;\n            const lineStyle = data.lineStyle;\n\n            const fillColor = data._fillTint;\n            const lineColor = data._lineTint;\n\n            context.lineWidth = lineStyle.width;\n\n            if (data.type === SHAPES.POLY)\n            {\n                context.beginPath();\n\n                let points = shape.points;\n                const holes = data.holes;\n                let outerArea;\n                let innerArea;\n                let px;\n                let py;\n\n                context.moveTo(points[0], points[1]);\n\n                for (let j = 2; j < points.length; j += 2)\n                {\n                    context.lineTo(points[j], points[j + 1]);\n                }\n\n                if (shape.closeStroke)\n                {\n                    context.closePath();\n                }\n\n                if (holes.length > 0)\n                {\n                    outerArea = 0;\n                    px = points[0];\n                    py = points[1];\n                    for (let j = 2; j + 2 < points.length; j += 2)\n                    {\n                        outerArea += ((points[j] - px) * (points[j + 3] - py))\n                            - ((points[j + 2] - px) * (points[j + 1] - py));\n                    }\n\n                    for (let k = 0; k < holes.length; k++)\n                    {\n                        points = holes[k].shape.points;\n\n                        if (!points)\n                        {\n                            continue;\n                        }\n\n                        innerArea = 0;\n                        px = points[0];\n                        py = points[1];\n                        for (let j = 2; j + 2 < points.length; j += 2)\n                        {\n                            innerArea += ((points[j] - px) * (points[j + 3] - py))\n                                - ((points[j + 2] - px) * (points[j + 1] - py));\n                        }\n\n                        if (innerArea * outerArea < 0)\n                        {\n                            context.moveTo(points[0], points[1]);\n\n                            for (let j = 2; j < points.length; j += 2)\n                            {\n                                context.lineTo(points[j], points[j + 1]);\n                            }\n                        }\n                        else\n                        {\n                            context.moveTo(points[points.length - 2], points[points.length - 1]);\n\n                            for (let j = points.length - 4; j >= 0; j -= 2)\n                            {\n                                context.lineTo(points[j], points[j + 1]);\n                            }\n                        }\n\n                        if (holes[k].shape.closeStroke)\n                        {\n                            context.closePath();\n                        }\n                    }\n                }\n\n                if (fillStyle.visible)\n                {\n                    context.globalAlpha = fillStyle.alpha * worldAlpha;\n\n                    context.fillStyle = `#${(`00000${(fillColor | 0).toString(16)}`).substr(-6)}`;\n                    context.fill();\n                }\n\n                if (lineStyle.visible)\n                {\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = `#${(`00000${(lineColor | 0).toString(16)}`).substr(-6)}`;\n                    context.stroke();\n                }\n            }\n            else if (data.type === SHAPES.RECT)\n            {\n                if (fillStyle.visible)\n                {\n                    context.globalAlpha = fillStyle.alpha * worldAlpha;\n                    context.fillStyle = `#${(`00000${(fillColor | 0).toString(16)}`).substr(-6)}`;\n                    context.fillRect(shape.x, shape.y, shape.width, shape.height);\n                }\n                if (lineStyle.visible)\n                {\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = `#${(`00000${(lineColor | 0).toString(16)}`).substr(-6)}`;\n                    context.strokeRect(shape.x, shape.y, shape.width, shape.height);\n                }\n            }\n            else if (data.type === SHAPES.CIRC)\n            {\n                // TODO - need to be Undefined!\n                context.beginPath();\n                context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);\n                context.closePath();\n\n                if (fillStyle.visible)\n                {\n                    context.globalAlpha = fillStyle.alpha * worldAlpha;\n                    context.fillStyle = `#${(`00000${(fillColor | 0).toString(16)}`).substr(-6)}`;\n                    context.fill();\n                }\n\n                if (lineStyle.visible)\n                {\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = `#${(`00000${(lineColor | 0).toString(16)}`).substr(-6)}`;\n                    context.stroke();\n                }\n            }\n            else if (data.type === SHAPES.ELIP)\n            {\n                // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\n\n                const w = shape.width * 2;\n                const h = shape.height * 2;\n\n                const x = shape.x - (w / 2);\n                const y = shape.y - (h / 2);\n\n                context.beginPath();\n\n                const kappa = 0.5522848;\n                const ox = (w / 2) * kappa; // control point offset horizontal\n                const oy = (h / 2) * kappa; // control point offset vertical\n                const xe = x + w; // x-end\n                const ye = y + h; // y-end\n                const xm = x + (w / 2); // x-middle\n                const ym = y + (h / 2); // y-middle\n\n                context.moveTo(x, ym);\n                context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n                context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n                context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n                context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n\n                context.closePath();\n\n                if (fillStyle.visible)\n                {\n                    context.globalAlpha = fillStyle.alpha * worldAlpha;\n                    context.fillStyle = `#${(`00000${(fillColor | 0).toString(16)}`).substr(-6)}`;\n                    context.fill();\n                }\n                if (lineStyle.visible)\n                {\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = `#${(`00000${(lineColor | 0).toString(16)}`).substr(-6)}`;\n                    context.stroke();\n                }\n            }\n            else if (data.type === SHAPES.RREC)\n            {\n                const rx = shape.x;\n                const ry = shape.y;\n                const width = shape.width;\n                const height = shape.height;\n                let radius = shape.radius;\n\n                const maxRadius = Math.min(width, height) / 2 | 0;\n\n                radius = radius > maxRadius ? maxRadius : radius;\n\n                context.beginPath();\n                context.moveTo(rx, ry + radius);\n                context.lineTo(rx, ry + height - radius);\n                context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);\n                context.lineTo(rx + width - radius, ry + height);\n                context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);\n                context.lineTo(rx + width, ry + radius);\n                context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);\n                context.lineTo(rx + radius, ry);\n                context.quadraticCurveTo(rx, ry, rx, ry + radius);\n                context.closePath();\n\n                if (fillStyle.visible)\n                {\n                    context.globalAlpha = fillStyle.alpha * worldAlpha;\n                    context.fillStyle = `#${(`00000${(fillColor | 0).toString(16)}`).substr(-6)}`;\n                    context.fill();\n                }\n                if (lineStyle.visible)\n                {\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = `#${(`00000${(lineColor | 0).toString(16)}`).substr(-6)}`;\n                    context.stroke();\n                }\n            }\n        }\n    }\n\n    /**\n     * Updates the tint of a graphics object\n     *\n     * @protected\n     * @param {PIXI.Graphics} graphics - the graphics that will have its tint updated\n     */\n    updateGraphicsTint(graphics)\n    {\n        graphics._prevTint = graphics.tint;\n        graphics.canvasTintDirty = graphics.geometry.dirty;\n\n        const tintR = ((graphics.tint >> 16) & 0xFF) / 255;\n        const tintG = ((graphics.tint >> 8) & 0xFF) / 255;\n        const tintB = (graphics.tint & 0xFF) / 255;\n        const graphicsData = graphics.geometry.graphicsData;\n\n        for (let i = 0; i < graphicsData.length; ++i)\n        {\n            const data = graphicsData[i];\n\n            const fillColor = data.fillStyle.color | 0;\n            const lineColor = data.lineStyle.color | 0;\n\n            // super inline, cos optimization :)\n            data._fillTint = (\n                (((fillColor >> 16) & 0xFF) / 255 * tintR * 255 << 16)\n                + (((fillColor >> 8) & 0xFF) / 255 * tintG * 255 << 8)\n                + (((fillColor & 0xFF) / 255) * tintB * 255)\n            );\n\n            data._lineTint = (\n                (((lineColor >> 16) & 0xFF) / 255 * tintR * 255 << 16)\n                + (((lineColor >> 8) & 0xFF) / 255 * tintG * 255 << 8)\n                + (((lineColor & 0xFF) / 255) * tintB * 255)\n            );\n        }\n    }\n\n    /**\n     * destroy graphics object\n     *\n     */\n    destroy()\n    {\n        this.renderer = null;\n    }\n}\n","import { Graphics } from '@pixi/graphics';\nimport { CanvasRenderer } from '@pixi/canvas-renderer';\nimport { RenderTexture, Texture } from '@pixi/core';\nimport { Matrix } from '@pixi/math';\n\nlet canvasRenderer;\nconst tempMatrix = new Matrix();\n\n/**\n * Generates a canvas texture. Only available with **pixi.js-legacy** bundle\n * or the **@pixi/canvas-graphics** package.\n * @method generateCanvasTexture\n * @memberof PIXI.Graphics#\n * @param {number} scaleMode - The scale mode of the texture.\n * @param {number} resolution - The resolution of the texture.\n * @return {PIXI.Texture} The new texture.\n */\nGraphics.prototype.generateCanvasTexture = function generateCanvasTexture(scaleMode, resolution = 1)\n{\n    const bounds = this.getLocalBounds();\n\n    const canvasBuffer = RenderTexture.create(bounds.width, bounds.height, scaleMode, resolution);\n\n    if (!canvasRenderer)\n    {\n        canvasRenderer = new CanvasRenderer();\n    }\n\n    this.transform.updateLocalTransform();\n    this.transform.localTransform.copyTo(tempMatrix);\n\n    tempMatrix.invert();\n\n    tempMatrix.tx -= bounds.x;\n    tempMatrix.ty -= bounds.y;\n\n    canvasRenderer.render(this, canvasBuffer, true, tempMatrix);\n\n    const texture = Texture.from(canvasBuffer.baseTexture._canvasRenderTarget.canvas, {\n        scaleMode,\n    });\n\n    texture.baseTexture.resolution = resolution;\n    texture.baseTexture.update();\n\n    return texture;\n};\n\nGraphics.prototype.cachedGraphicsData = [];\n\n/**\n * Renders the object using the Canvas renderer\n *\n * @method _renderCanvas\n * @memberof PIXI.Graphics#\n * @private\n * @param {PIXI.CanvasRenderer} renderer - The renderer\n */\nGraphics.prototype._renderCanvas = function _renderCanvas(renderer)\n{\n    if (this.isMask === true)\n    {\n        return;\n    }\n\n    this.finishPoly();\n    renderer.plugins.graphics.render(this);\n};\n"]},"metadata":{},"sourceType":"module"}