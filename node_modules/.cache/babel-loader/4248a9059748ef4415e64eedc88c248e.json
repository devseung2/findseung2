{"ast":null,"code":"/*!\n * @pixi/canvas-sprite-tiling - v5.2.0\n * Compiled Wed, 06 Nov 2019 02:32:43 UTC\n *\n * @pixi/canvas-sprite-tiling is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { TilingSprite } from '@pixi/sprite-tiling';\nimport { canvasUtils } from '@pixi/canvas-renderer';\nimport { CanvasRenderTarget } from '@pixi/utils';\n/**\n * Renders the object using the Canvas renderer\n *\n * @protected\n * @function _renderCanvas\n * @memberof PIXI.TilingSprite#\n * @param {PIXI.CanvasRenderer} renderer - a reference to the canvas renderer\n */\n\nTilingSprite.prototype._renderCanvas = function _renderCanvas(renderer) {\n  var texture = this._texture;\n\n  if (!texture.baseTexture.valid) {\n    return;\n  }\n\n  var context = renderer.context;\n  var transform = this.worldTransform;\n  var resolution = renderer.resolution;\n  var baseTexture = texture.baseTexture;\n  var source = baseTexture.getDrawableSource();\n  var baseTextureResolution = baseTexture.resolution;\n  var modX = this.tilePosition.x / this.tileScale.x % texture._frame.width * baseTextureResolution;\n  var modY = this.tilePosition.y / this.tileScale.y % texture._frame.height * baseTextureResolution; // create a nice shiny pattern!\n\n  if (this._textureID !== this._texture._updateID || this._cachedTint !== this.tint) {\n    this._textureID = this._texture._updateID; // cut an object from a spritesheet..\n\n    var tempCanvas = new CanvasRenderTarget(texture._frame.width, texture._frame.height, baseTextureResolution); // Tint the tiling sprite\n\n    if (this.tint !== 0xFFFFFF) {\n      this._tintedCanvas = canvasUtils.getTintedCanvas(this, this.tint);\n      tempCanvas.context.drawImage(this._tintedCanvas, 0, 0);\n    } else {\n      tempCanvas.context.drawImage(source, -texture._frame.x * baseTextureResolution, -texture._frame.y * baseTextureResolution);\n    }\n\n    this._cachedTint = this.tint;\n    this._canvasPattern = tempCanvas.context.createPattern(tempCanvas.canvas, 'repeat');\n  } // set context state..\n\n\n  context.globalAlpha = this.worldAlpha;\n  context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, transform.tx * resolution, transform.ty * resolution);\n  renderer.setBlendMode(this.blendMode); // fill the pattern!\n\n  context.fillStyle = this._canvasPattern; // TODO - this should be rolled into the setTransform above..\n\n  context.scale(this.tileScale.x / baseTextureResolution, this.tileScale.y / baseTextureResolution);\n  var anchorX = this.anchor.x * -this._width;\n  var anchorY = this.anchor.y * -this._height;\n\n  if (this.uvRespectAnchor) {\n    context.translate(modX, modY);\n    context.fillRect(-modX + anchorX, -modY + anchorY, this._width / this.tileScale.x * baseTextureResolution, this._height / this.tileScale.y * baseTextureResolution);\n  } else {\n    context.translate(modX + anchorX, modY + anchorY);\n    context.fillRect(-modX, -modY, this._width / this.tileScale.x * baseTextureResolution, this._height / this.tileScale.y * baseTextureResolution);\n  }\n};","map":{"version":3,"sources":["../src/TilingSprite.js"],"names":["const"],"mappings":"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","sourcesContent":["import { TilingSprite } from '@pixi/sprite-tiling';\nimport { canvasUtils } from '@pixi/canvas-renderer';\nimport { CanvasRenderTarget } from '@pixi/utils';\n\n/**\n * Renders the object using the Canvas renderer\n *\n * @protected\n * @function _renderCanvas\n * @memberof PIXI.TilingSprite#\n * @param {PIXI.CanvasRenderer} renderer - a reference to the canvas renderer\n */\nTilingSprite.prototype._renderCanvas = function _renderCanvas(renderer)\n{\n    const texture = this._texture;\n\n    if (!texture.baseTexture.valid)\n    {\n        return;\n    }\n\n    const context = renderer.context;\n    const transform = this.worldTransform;\n    const resolution = renderer.resolution;\n    const baseTexture = texture.baseTexture;\n    const source = baseTexture.getDrawableSource();\n    const baseTextureResolution = baseTexture.resolution;\n    const modX = ((this.tilePosition.x / this.tileScale.x) % texture._frame.width) * baseTextureResolution;\n    const modY = ((this.tilePosition.y / this.tileScale.y) % texture._frame.height) * baseTextureResolution;\n\n    // create a nice shiny pattern!\n    if (this._textureID !== this._texture._updateID || this._cachedTint !== this.tint)\n    {\n        this._textureID = this._texture._updateID;\n        // cut an object from a spritesheet..\n        const tempCanvas = new CanvasRenderTarget(texture._frame.width,\n            texture._frame.height,\n            baseTextureResolution);\n\n        // Tint the tiling sprite\n        if (this.tint !== 0xFFFFFF)\n        {\n            this._tintedCanvas = canvasUtils.getTintedCanvas(this, this.tint);\n            tempCanvas.context.drawImage(this._tintedCanvas, 0, 0);\n        }\n        else\n        {\n            tempCanvas.context.drawImage(source,\n                -texture._frame.x * baseTextureResolution, -texture._frame.y * baseTextureResolution);\n        }\n        this._cachedTint = this.tint;\n        this._canvasPattern = tempCanvas.context.createPattern(tempCanvas.canvas, 'repeat');\n    }\n\n    // set context state..\n    context.globalAlpha = this.worldAlpha;\n    context.setTransform(transform.a * resolution,\n        transform.b * resolution,\n        transform.c * resolution,\n        transform.d * resolution,\n        transform.tx * resolution,\n        transform.ty * resolution);\n\n    renderer.setBlendMode(this.blendMode);\n\n    // fill the pattern!\n    context.fillStyle = this._canvasPattern;\n\n    // TODO - this should be rolled into the setTransform above..\n    context.scale(this.tileScale.x / baseTextureResolution, this.tileScale.y / baseTextureResolution);\n\n    const anchorX = this.anchor.x * -this._width;\n    const anchorY = this.anchor.y * -this._height;\n\n    if (this.uvRespectAnchor)\n    {\n        context.translate(modX, modY);\n\n        context.fillRect(-modX + anchorX, -modY + anchorY,\n            this._width / this.tileScale.x * baseTextureResolution,\n            this._height / this.tileScale.y * baseTextureResolution);\n    }\n    else\n    {\n        context.translate(modX + anchorX, modY + anchorY);\n\n        context.fillRect(-modX, -modY,\n            this._width / this.tileScale.x * baseTextureResolution,\n            this._height / this.tileScale.y * baseTextureResolution);\n    }\n};\n"]},"metadata":{},"sourceType":"module"}