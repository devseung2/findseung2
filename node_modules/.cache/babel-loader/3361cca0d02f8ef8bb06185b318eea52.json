{"ast":null,"code":"/*!\n * @pixi/canvas-sprite - v5.2.0\n * Compiled Wed, 06 Nov 2019 02:32:43 UTC\n *\n * @pixi/canvas-sprite is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { SCALE_MODES, BLEND_MODES } from '@pixi/constants';\nimport { Matrix, groupD8 } from '@pixi/math';\nimport { canvasUtils } from '@pixi/canvas-renderer';\nimport { Sprite } from '@pixi/sprite';\nvar canvasRenderWorldTransform = new Matrix();\n/**\n * Types that can be passed to drawImage\n * @typedef {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap} ICanvasImageSource\n * @memberof PIXI\n */\n\n/**\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original PixiJS version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now\n * share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's CanvasSpriteRenderer:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/CanvasSpriteRenderer.java\n */\n\n/**\n * Renderer dedicated to drawing and batching sprites.\n *\n * @class\n * @protected\n * @memberof PIXI\n */\n\nvar CanvasSpriteRenderer = function CanvasSpriteRenderer(renderer) {\n  this.renderer = renderer;\n};\n/**\n * Renders the sprite object.\n *\n * @param {PIXI.Sprite} sprite - the sprite to render when using this spritebatch\n */\n\n\nCanvasSpriteRenderer.prototype.render = function render(sprite) {\n  var texture = sprite._texture;\n  var renderer = this.renderer;\n  var context = renderer.context;\n  var width = texture._frame.width;\n  var height = texture._frame.height;\n  var wt = sprite.transform.worldTransform;\n  var dx = 0;\n  var dy = 0;\n  var source = texture.baseTexture.getDrawableSource();\n\n  if (texture.orig.width <= 0 || texture.orig.height <= 0 || !source) {\n    return;\n  }\n\n  if (!texture.valid) {\n    return;\n  }\n\n  renderer.setBlendMode(sprite.blendMode, true);\n  renderer.context.globalAlpha = sprite.worldAlpha; // If smoothingEnabled is supported and we need to change the smoothing property for sprite texture\n\n  var smoothingEnabled = texture.baseTexture.scaleMode === SCALE_MODES.LINEAR;\n\n  if (renderer.smoothProperty && renderer.context[renderer.smoothProperty] !== smoothingEnabled) {\n    context[renderer.smoothProperty] = smoothingEnabled;\n  }\n\n  if (texture.trim) {\n    dx = texture.trim.width / 2 + texture.trim.x - sprite.anchor.x * texture.orig.width;\n    dy = texture.trim.height / 2 + texture.trim.y - sprite.anchor.y * texture.orig.height;\n  } else {\n    dx = (0.5 - sprite.anchor.x) * texture.orig.width;\n    dy = (0.5 - sprite.anchor.y) * texture.orig.height;\n  }\n\n  if (texture.rotate) {\n    wt.copyTo(canvasRenderWorldTransform);\n    wt = canvasRenderWorldTransform;\n    groupD8.matrixAppendRotationInv(wt, texture.rotate, dx, dy); // the anchor has already been applied above, so lets set it to zero\n\n    dx = 0;\n    dy = 0;\n  }\n\n  dx -= width / 2;\n  dy -= height / 2; // Allow for pixel rounding\n\n  if (sprite.roundPixels) {\n    renderer.context.setTransform(wt.a, wt.b, wt.c, wt.d, wt.tx * renderer.resolution | 0, wt.ty * renderer.resolution | 0);\n    dx = dx | 0;\n    dy = dy | 0;\n  } else {\n    renderer.context.setTransform(wt.a, wt.b, wt.c, wt.d, wt.tx * renderer.resolution, wt.ty * renderer.resolution);\n  }\n\n  var resolution = texture.baseTexture.resolution;\n  var outerBlend = renderer._outerBlend;\n\n  if (outerBlend) {\n    context.save();\n    context.beginPath();\n    context.rect(dx * renderer.resolution, dy * renderer.resolution, width * renderer.resolution, height * renderer.resolution);\n    context.clip();\n  }\n\n  if (sprite.tint !== 0xFFFFFF) {\n    if (sprite._cachedTint !== sprite.tint || sprite._tintedCanvas.tintId !== sprite._texture._updateID) {\n      sprite._cachedTint = sprite.tint; // TODO clean up caching - how to clean up the caches?\n\n      sprite._tintedCanvas = canvasUtils.getTintedCanvas(sprite, sprite.tint);\n    }\n\n    context.drawImage(sprite._tintedCanvas, 0, 0, Math.floor(width * resolution), Math.floor(height * resolution), Math.floor(dx * renderer.resolution), Math.floor(dy * renderer.resolution), Math.floor(width * renderer.resolution), Math.floor(height * renderer.resolution));\n  } else {\n    context.drawImage(source, texture._frame.x * resolution, texture._frame.y * resolution, Math.floor(width * resolution), Math.floor(height * resolution), Math.floor(dx * renderer.resolution), Math.floor(dy * renderer.resolution), Math.floor(width * renderer.resolution), Math.floor(height * renderer.resolution));\n  }\n\n  if (outerBlend) {\n    context.restore();\n  } // just in case, leaking outer blend here will be catastrophic!\n\n\n  renderer.setBlendMode(BLEND_MODES.NORMAL);\n};\n/**\n * destroy the sprite object.\n *\n */\n\n\nCanvasSpriteRenderer.prototype.destroy = function destroy() {\n  this.renderer = null;\n};\n/**\n * Cached tinted texture.\n * @memberof PIXI.Sprite#\n * @member {HTMLCanvasElement} _tintedCanvas\n * @protected\n */\n\n\nSprite.prototype._tintedCanvas = null;\n/**\n* Renders the object using the Canvas renderer\n*\n* @private\n* @method _renderCanvas\n* @memberof PIXI.Sprite#\n* @param {PIXI.CanvasRenderer} renderer - The renderer\n*/\n\nSprite.prototype._renderCanvas = function _renderCanvas(renderer) {\n  renderer.plugins.sprite.render(this);\n};\n\nexport { CanvasSpriteRenderer };","map":{"version":3,"sources":["../src/CanvasSpriteRenderer.js","../src/Sprite.js"],"names":["const","let"],"mappings":"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","sourcesContent":["import { SCALE_MODES, BLEND_MODES } from '@pixi/constants';\nimport { Matrix, groupD8 } from '@pixi/math';\nimport { canvasUtils } from '@pixi/canvas-renderer';\n\nconst canvasRenderWorldTransform = new Matrix();\n\n/**\n * Types that can be passed to drawImage\n * @typedef {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap} ICanvasImageSource\n * @memberof PIXI\n */\n\n/**\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original PixiJS version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now\n * share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's CanvasSpriteRenderer:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/CanvasSpriteRenderer.java\n */\n\n/**\n * Renderer dedicated to drawing and batching sprites.\n *\n * @class\n * @protected\n * @memberof PIXI\n */\nexport class CanvasSpriteRenderer\n{\n    /**\n     * @param {PIXI.Renderer} renderer -The renderer sprite this batch works for.\n     */\n    constructor(renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * Renders the sprite object.\n     *\n     * @param {PIXI.Sprite} sprite - the sprite to render when using this spritebatch\n     */\n    render(sprite)\n    {\n        const texture = sprite._texture;\n        const renderer = this.renderer;\n        const context = renderer.context;\n\n        const width = texture._frame.width;\n        const height = texture._frame.height;\n\n        let wt = sprite.transform.worldTransform;\n        let dx = 0;\n        let dy = 0;\n\n        const source = texture.baseTexture.getDrawableSource();\n\n        if (texture.orig.width <= 0 || texture.orig.height <= 0 || !source)\n        {\n            return;\n        }\n\n        if (!texture.valid)\n        {\n            return;\n        }\n\n        renderer.setBlendMode(sprite.blendMode, true);\n\n        renderer.context.globalAlpha = sprite.worldAlpha;\n\n        // If smoothingEnabled is supported and we need to change the smoothing property for sprite texture\n        const smoothingEnabled = texture.baseTexture.scaleMode === SCALE_MODES.LINEAR;\n\n        if (renderer.smoothProperty && renderer.context[renderer.smoothProperty] !== smoothingEnabled)\n        {\n            context[renderer.smoothProperty] = smoothingEnabled;\n        }\n\n        if (texture.trim)\n        {\n            dx = (texture.trim.width / 2) + texture.trim.x - (sprite.anchor.x * texture.orig.width);\n            dy = (texture.trim.height / 2) + texture.trim.y - (sprite.anchor.y * texture.orig.height);\n        }\n        else\n        {\n            dx = (0.5 - sprite.anchor.x) * texture.orig.width;\n            dy = (0.5 - sprite.anchor.y) * texture.orig.height;\n        }\n\n        if (texture.rotate)\n        {\n            wt.copyTo(canvasRenderWorldTransform);\n            wt = canvasRenderWorldTransform;\n            groupD8.matrixAppendRotationInv(wt, texture.rotate, dx, dy);\n            // the anchor has already been applied above, so lets set it to zero\n            dx = 0;\n            dy = 0;\n        }\n\n        dx -= width / 2;\n        dy -= height / 2;\n\n        // Allow for pixel rounding\n        if (sprite.roundPixels)\n        {\n            renderer.context.setTransform(\n                wt.a,\n                wt.b,\n                wt.c,\n                wt.d,\n                (wt.tx * renderer.resolution) | 0,\n                (wt.ty * renderer.resolution) | 0\n            );\n\n            dx = dx | 0;\n            dy = dy | 0;\n        }\n        else\n        {\n            renderer.context.setTransform(\n                wt.a,\n                wt.b,\n                wt.c,\n                wt.d,\n                wt.tx * renderer.resolution,\n                wt.ty * renderer.resolution\n            );\n        }\n\n        const resolution = texture.baseTexture.resolution;\n        const outerBlend = renderer._outerBlend;\n\n        if (outerBlend)\n        {\n            context.save();\n            context.beginPath();\n            context.rect(\n                dx * renderer.resolution,\n                dy * renderer.resolution,\n                width * renderer.resolution,\n                height * renderer.resolution\n            );\n            context.clip();\n        }\n\n        if (sprite.tint !== 0xFFFFFF)\n        {\n            if (sprite._cachedTint !== sprite.tint || sprite._tintedCanvas.tintId !== sprite._texture._updateID)\n            {\n                sprite._cachedTint = sprite.tint;\n\n                // TODO clean up caching - how to clean up the caches?\n                sprite._tintedCanvas = canvasUtils.getTintedCanvas(sprite, sprite.tint);\n            }\n\n            context.drawImage(\n                sprite._tintedCanvas,\n                0,\n                0,\n                Math.floor(width * resolution),\n                Math.floor(height * resolution),\n                Math.floor(dx * renderer.resolution),\n                Math.floor(dy * renderer.resolution),\n                Math.floor(width * renderer.resolution),\n                Math.floor(height * renderer.resolution)\n            );\n        }\n        else\n        {\n            context.drawImage(\n                source,\n                texture._frame.x * resolution,\n                texture._frame.y * resolution,\n                Math.floor(width * resolution),\n                Math.floor(height * resolution),\n                Math.floor(dx * renderer.resolution),\n                Math.floor(dy * renderer.resolution),\n                Math.floor(width * renderer.resolution),\n                Math.floor(height * renderer.resolution)\n            );\n        }\n\n        if (outerBlend)\n        {\n            context.restore();\n        }\n        // just in case, leaking outer blend here will be catastrophic!\n        renderer.setBlendMode(BLEND_MODES.NORMAL);\n    }\n\n    /**\n     * destroy the sprite object.\n     *\n     */\n    destroy()\n    {\n        this.renderer = null;\n    }\n}\n","import { Sprite } from '@pixi/sprite';\n\n/**\n * Cached tinted texture.\n * @memberof PIXI.Sprite#\n * @member {HTMLCanvasElement} _tintedCanvas\n * @protected\n */\nSprite.prototype._tintedCanvas = null;\n\n/**\n* Renders the object using the Canvas renderer\n*\n* @private\n* @method _renderCanvas\n* @memberof PIXI.Sprite#\n* @param {PIXI.CanvasRenderer} renderer - The renderer\n*/\nSprite.prototype._renderCanvas = function _renderCanvas(renderer)\n{\n    renderer.plugins.sprite.render(this);\n};\n"]},"metadata":{},"sourceType":"module"}