{"ast":null,"code":"/*!\n * @pixi/canvas-mesh - v5.2.0\n * Compiled Wed, 06 Nov 2019 02:32:43 UTC\n *\n * @pixi/canvas-mesh is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { DRAW_MODES } from '@pixi/constants';\nimport { settings } from '@pixi/settings';\nimport { MeshMaterial, Mesh } from '@pixi/mesh';\nimport { canvasUtils } from '@pixi/canvas-renderer';\nimport { NineSlicePlane, SimpleMesh, SimpleRope } from '@pixi/mesh-extras';\n/**\n * Renderer dedicated to meshes.\n *\n * @class\n * @protected\n * @memberof PIXI\n */\n\nvar CanvasMeshRenderer = function CanvasMeshRenderer(renderer) {\n  this.renderer = renderer;\n};\n/**\n * Renders the Mesh\n *\n * @param {PIXI.Mesh} mesh - the Mesh to render\n */\n\n\nCanvasMeshRenderer.prototype.render = function render(mesh) {\n  var renderer = this.renderer;\n  var context = renderer.context;\n  var transform = mesh.worldTransform;\n  var res = renderer.resolution;\n\n  if (mesh.roundPixels) {\n    context.setTransform(transform.a * res, transform.b * res, transform.c * res, transform.d * res, transform.tx * res | 0, transform.ty * res | 0);\n  } else {\n    context.setTransform(transform.a * res, transform.b * res, transform.c * res, transform.d * res, transform.tx * res, transform.ty * res);\n  }\n\n  renderer.context.globalAlpha = mesh.worldAlpha;\n  renderer.setBlendMode(mesh.blendMode);\n\n  if (mesh.drawMode !== DRAW_MODES.TRIANGLES) {\n    this._renderTriangleMesh(mesh);\n  } else {\n    this._renderTriangles(mesh);\n  }\n};\n/**\n * Draws the object in Triangle Mesh mode\n *\n * @private\n * @param {PIXI.Mesh} mesh - the Mesh to render\n */\n\n\nCanvasMeshRenderer.prototype._renderTriangleMesh = function _renderTriangleMesh(mesh) {\n  // draw triangles!!\n  var length = mesh.geometry.buffers[0].data.length;\n\n  for (var i = 0; i < length - 2; i++) {\n    // draw some triangles!\n    var index = i * 2;\n\n    this._renderDrawTriangle(mesh, index, index + 2, index + 4);\n  }\n};\n/**\n * Draws the object in triangle mode using canvas\n *\n * @private\n * @param {PIXI.Mesh} mesh - the current mesh\n */\n\n\nCanvasMeshRenderer.prototype._renderTriangles = function _renderTriangles(mesh) {\n  // draw triangles!!\n  var indices = mesh.geometry.getIndex().data;\n  var length = indices.length;\n\n  for (var i = 0; i < length; i += 3) {\n    // draw some triangles!\n    var index0 = indices[i] * 2;\n    var index1 = indices[i + 1] * 2;\n    var index2 = indices[i + 2] * 2;\n\n    this._renderDrawTriangle(mesh, index0, index1, index2);\n  }\n};\n/**\n * Draws one of the triangles that from the Mesh\n *\n * @private\n * @param {PIXI.Mesh} mesh - the current mesh\n * @param {number} index0 - the index of the first vertex\n * @param {number} index1 - the index of the second vertex\n * @param {number} index2 - the index of the third vertex\n */\n\n\nCanvasMeshRenderer.prototype._renderDrawTriangle = function _renderDrawTriangle(mesh, index0, index1, index2) {\n  var context = this.renderer.context;\n  var vertices = mesh.geometry.buffers[0].data;\n  var uvs = mesh.uvs;\n  var texture = mesh.texture;\n\n  if (!texture.valid) {\n    return;\n  }\n\n  var base = texture.baseTexture;\n  var textureSource = base.getDrawableSource();\n  var textureWidth = base.width;\n  var textureHeight = base.height;\n  var u0 = uvs[index0] * base.width;\n  var u1 = uvs[index1] * base.width;\n  var u2 = uvs[index2] * base.width;\n  var v0 = uvs[index0 + 1] * base.height;\n  var v1 = uvs[index1 + 1] * base.height;\n  var v2 = uvs[index2 + 1] * base.height;\n  var x0 = vertices[index0];\n  var x1 = vertices[index1];\n  var x2 = vertices[index2];\n  var y0 = vertices[index0 + 1];\n  var y1 = vertices[index1 + 1];\n  var y2 = vertices[index2 + 1];\n  var canvasPadding = mesh.canvasPadding / this.renderer.resolution;\n\n  if (canvasPadding > 0) {\n    var paddingX = canvasPadding / Math.abs(mesh.worldTransform.a);\n    var paddingY = canvasPadding / Math.abs(mesh.worldTransform.d);\n    var centerX = (x0 + x1 + x2) / 3;\n    var centerY = (y0 + y1 + y2) / 3;\n    var normX = x0 - centerX;\n    var normY = y0 - centerY;\n    var dist = Math.sqrt(normX * normX + normY * normY);\n    x0 = centerX + normX / dist * (dist + paddingX);\n    y0 = centerY + normY / dist * (dist + paddingY); //\n\n    normX = x1 - centerX;\n    normY = y1 - centerY;\n    dist = Math.sqrt(normX * normX + normY * normY);\n    x1 = centerX + normX / dist * (dist + paddingX);\n    y1 = centerY + normY / dist * (dist + paddingY);\n    normX = x2 - centerX;\n    normY = y2 - centerY;\n    dist = Math.sqrt(normX * normX + normY * normY);\n    x2 = centerX + normX / dist * (dist + paddingX);\n    y2 = centerY + normY / dist * (dist + paddingY);\n  }\n\n  context.save();\n  context.beginPath();\n  context.moveTo(x0, y0);\n  context.lineTo(x1, y1);\n  context.lineTo(x2, y2);\n  context.closePath();\n  context.clip(); // Compute matrix transform\n\n  var delta = u0 * v1 + v0 * u2 + u1 * v2 - v1 * u2 - v0 * u1 - u0 * v2;\n  var deltaA = x0 * v1 + v0 * x2 + x1 * v2 - v1 * x2 - v0 * x1 - x0 * v2;\n  var deltaB = u0 * x1 + x0 * u2 + u1 * x2 - x1 * u2 - x0 * u1 - u0 * x2;\n  var deltaC = u0 * v1 * x2 + v0 * x1 * u2 + x0 * u1 * v2 - x0 * v1 * u2 - v0 * u1 * x2 - u0 * x1 * v2;\n  var deltaD = y0 * v1 + v0 * y2 + y1 * v2 - v1 * y2 - v0 * y1 - y0 * v2;\n  var deltaE = u0 * y1 + y0 * u2 + u1 * y2 - y1 * u2 - y0 * u1 - u0 * y2;\n  var deltaF = u0 * v1 * y2 + v0 * y1 * u2 + y0 * u1 * v2 - y0 * v1 * u2 - v0 * u1 * y2 - u0 * y1 * v2;\n  context.transform(deltaA / delta, deltaD / delta, deltaB / delta, deltaE / delta, deltaC / delta, deltaF / delta);\n  context.drawImage(textureSource, 0, 0, textureWidth * base.resolution, textureHeight * base.resolution, 0, 0, textureWidth, textureHeight);\n  context.restore();\n  this.renderer.invalidateBlendMode();\n};\n/**\n * Renders a flat Mesh\n *\n * @private\n * @param {PIXI.Mesh} mesh - The Mesh to render\n */\n\n\nCanvasMeshRenderer.prototype.renderMeshFlat = function renderMeshFlat(mesh) {\n  var context = this.renderer.context;\n  var vertices = mesh.geometry.getBuffer('aVertexPosition').data;\n  var length = vertices.length / 2; // this.count++;\n\n  context.beginPath();\n\n  for (var i = 1; i < length - 2; ++i) {\n    // draw some triangles!\n    var index = i * 2;\n    var x0 = vertices[index];\n    var y0 = vertices[index + 1];\n    var x1 = vertices[index + 2];\n    var y1 = vertices[index + 3];\n    var x2 = vertices[index + 4];\n    var y2 = vertices[index + 5];\n    context.moveTo(x0, y0);\n    context.lineTo(x1, y1);\n    context.lineTo(x2, y2);\n  }\n\n  context.fillStyle = '#FF0000';\n  context.fill();\n  context.closePath();\n};\n/**\n * destroy the the renderer.\n *\n */\n\n\nCanvasMeshRenderer.prototype.destroy = function destroy() {\n  this.renderer = null;\n};\n/**\n * Default `canvasPadding` for canvas-based Mesh rendering.\n *\n * @see PIXI.Mesh2d#canvasPadding\n * @static\n * @name MESH_CANVAS_PADDING\n * @memberof PIXI.settings\n * @type {number}\n * @default 0\n */\n\n\nsettings.MESH_CANVAS_PADDING = 0;\n/**\n * Renders the mesh using the Canvas renderer\n *\n * @protected\n * @method render\n * @memberof PIXI.MeshMaterial#\n * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.\n * @param {PIXI.Mesh} mesh - Mesh to render.\n */\n\nMeshMaterial.prototype._renderCanvas = function _renderCanvas(renderer, mesh) {\n  renderer.plugins.mesh.render(mesh);\n};\n/**\n * Cached tint value so we can tell when the tint is changed.\n * @memberof PIXI.NineSlicePlane#\n * @member {number} _cachedTint\n * @protected\n */\n\n\nNineSlicePlane.prototype._cachedTint = 0xFFFFFF;\n/**\n * Cached tinted texture.\n * @memberof PIXI.NineSlicePlane#\n * @member {HTMLCanvasElement} _tintedCanvas\n * @protected\n */\n\nNineSlicePlane.prototype._tintedCanvas = null;\n/**\n * Temporary storage for canvas source coords\n * @memberof PIXI.NineSlicePlane#\n * @member {number[]} _canvasUvs\n * @private\n */\n\nNineSlicePlane.prototype._canvasUvs = null;\n/**\n * Renders the object using the Canvas renderer\n *\n * @private\n * @method _renderCanvas\n * @memberof PIXI.NineSlicePlane#\n * @param {PIXI.CanvasRenderer} renderer - The canvas renderer to render with.\n */\n\nNineSlicePlane.prototype._renderCanvas = function _renderCanvas(renderer) {\n  var context = renderer.context;\n  var transform = this.worldTransform;\n  var res = renderer.resolution;\n  var isTinted = this.tint !== 0xFFFFFF;\n  var texture = this.texture; // Work out tinting\n\n  if (isTinted) {\n    if (this._cachedTint !== this.tint) {\n      // Tint has changed, need to update the tinted texture and use that instead\n      this._cachedTint = this.tint;\n      this._tintedCanvas = canvasUtils.getTintedCanvas(this, this.tint);\n    }\n  }\n\n  var textureSource = !isTinted ? texture.baseTexture.getDrawableSource() : this._tintedCanvas;\n\n  if (!this._canvasUvs) {\n    this._canvasUvs = [0, 0, 0, 0, 0, 0, 0, 0];\n  }\n\n  var vertices = this.vertices;\n  var uvs = this._canvasUvs;\n  var u0 = isTinted ? 0 : texture.frame.x;\n  var v0 = isTinted ? 0 : texture.frame.y;\n  var u1 = u0 + texture.frame.width;\n  var v1 = v0 + texture.frame.height;\n  uvs[0] = u0;\n  uvs[1] = u0 + this._leftWidth;\n  uvs[2] = u1 - this._rightWidth;\n  uvs[3] = u1;\n  uvs[4] = v0;\n  uvs[5] = v0 + this._topHeight;\n  uvs[6] = v1 - this._bottomHeight;\n  uvs[7] = v1;\n\n  for (var i = 0; i < 8; i++) {\n    uvs[i] *= texture.baseTexture.resolution;\n  }\n\n  context.globalAlpha = this.worldAlpha;\n  renderer.setBlendMode(this.blendMode);\n\n  if (this.roundPixels) {\n    context.setTransform(transform.a * res, transform.b * res, transform.c * res, transform.d * res, transform.tx * res | 0, transform.ty * res | 0);\n  } else {\n    context.setTransform(transform.a * res, transform.b * res, transform.c * res, transform.d * res, transform.tx * res, transform.ty * res);\n  }\n\n  for (var row = 0; row < 3; row++) {\n    for (var col = 0; col < 3; col++) {\n      var ind = col * 2 + row * 8;\n      var sw = Math.max(1, uvs[col + 1] - uvs[col]);\n      var sh = Math.max(1, uvs[row + 5] - uvs[row + 4]);\n      var dw = Math.max(1, vertices[ind + 10] - vertices[ind]);\n      var dh = Math.max(1, vertices[ind + 11] - vertices[ind + 1]);\n      context.drawImage(textureSource, uvs[col], uvs[row + 4], sw, sh, vertices[ind], vertices[ind + 1], dw, dh);\n    }\n  }\n};\n/**\n * Renders the object using the Canvas renderer\n *\n * @private\n * @method _renderCanvas\n * @memberof PIXI.Mesh#\n * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.\n */\n\n\nMesh.prototype._renderCanvas = function _renderCanvas(renderer) {\n  if (this.shader.uvMatrix) {\n    this.shader.uvMatrix.update();\n    this.calculateUvs();\n  }\n\n  this.material._renderCanvas(renderer, this);\n}; // IMPORTANT: Please do NOT use this as a precedent to use `settings` after the object is created\n// this was merely created to completely decouple canvas from the base Mesh class and we are\n// unable to add `canvasPadding` in the constructor anymore, as the case was for PixiJS v4.\n\n/**\n * Internal variable for `canvasPadding`.\n *\n * @private\n * @memberof PIXI.Mesh\n * @member {number}\n * @default null\n */\n\n\nMesh.prototype._canvasPadding = null;\n/**\n * Triangles in canvas mode are automatically antialiased, use this value to force triangles\n * to overlap a bit with each other. To set the global default, set {@link PIXI.settings.MESH_CANVAS_PADDING}\n *\n * @see PIXI.settings.MESH_CANVAS_PADDING\n * @member {number} canvasPadding\n * @memberof PIXI.SimpleMesh#\n * @default 0\n */\n\nObject.defineProperty(Mesh.prototype, 'canvasPadding', {\n  get: function get() {\n    return this._canvasPadding !== null ? this._canvasPadding : settings.MESH_CANVAS_PADDING;\n  },\n  set: function set(value) {\n    this._canvasPadding = value;\n  }\n});\n/**\n * Renders the object using the Canvas renderer\n *\n * @private\n * @method _renderCanvas\n * @memberof PIXI.Mesh#\n * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.\n */\n\nSimpleMesh.prototype._renderCanvas = function _renderCanvas(renderer) {\n  if (this.autoUpdate) {\n    this.geometry.getBuffer('aVertexPosition').update();\n  }\n\n  if (this.shader.update) {\n    this.shader.update();\n  }\n\n  this.calculateUvs();\n\n  this.material._renderCanvas(renderer, this);\n};\n/**\n * Renders the object using the Canvas renderer\n *\n * @protected\n * @method _renderCanvas\n * @memberof PIXI.Mesh#\n * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.\n */\n\n\nSimpleRope.prototype._renderCanvas = function _renderCanvas(renderer) {\n  if (this.autoUpdate || this.geometry.width !== this.shader.texture.height) {\n    this.geometry.width = this.shader.texture.height;\n    this.geometry.update();\n  }\n\n  if (this.shader.update) {\n    this.shader.update();\n  }\n\n  this.calculateUvs();\n\n  this.material._renderCanvas(renderer, this);\n};\n\nexport { CanvasMeshRenderer };","map":{"version":3,"sources":["../src/CanvasMeshRenderer.js","../src/settings.js","../src/MeshMaterial.js","../src/NineSlicePlane.js","../src/Mesh.js","../src/SimpleMesh.js","../src/SimpleRope.js"],"names":["const","let"],"mappings":"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","sourcesContent":["import { DRAW_MODES } from '@pixi/constants';\n\n/**\n * Renderer dedicated to meshes.\n *\n * @class\n * @protected\n * @memberof PIXI\n */\nexport class CanvasMeshRenderer\n{\n    /**\n     * @param {PIXI.CanvasRenderer} renderer - The renderer this downport works for\n     */\n    constructor(renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * Renders the Mesh\n     *\n     * @param {PIXI.Mesh} mesh - the Mesh to render\n     */\n    render(mesh)\n    {\n        const renderer = this.renderer;\n        const context = renderer.context;\n\n        const transform = mesh.worldTransform;\n        const res = renderer.resolution;\n\n        if (mesh.roundPixels)\n        {\n            context.setTransform(\n                transform.a * res,\n                transform.b * res,\n                transform.c * res,\n                transform.d * res,\n                (transform.tx * res) | 0,\n                (transform.ty * res) | 0\n            );\n        }\n        else\n        {\n            context.setTransform(\n                transform.a * res,\n                transform.b * res,\n                transform.c * res,\n                transform.d * res,\n                transform.tx * res,\n                transform.ty * res\n            );\n        }\n\n        renderer.context.globalAlpha = mesh.worldAlpha;\n        renderer.setBlendMode(mesh.blendMode);\n\n        if (mesh.drawMode !== DRAW_MODES.TRIANGLES)\n        {\n            this._renderTriangleMesh(mesh);\n        }\n        else\n        {\n            this._renderTriangles(mesh);\n        }\n    }\n\n    /**\n     * Draws the object in Triangle Mesh mode\n     *\n     * @private\n     * @param {PIXI.Mesh} mesh - the Mesh to render\n     */\n    _renderTriangleMesh(mesh)\n    {\n        // draw triangles!!\n        const length = mesh.geometry.buffers[0].data.length;\n\n        for (let i = 0; i < length - 2; i++)\n        {\n            // draw some triangles!\n            const index = i * 2;\n\n            this._renderDrawTriangle(mesh, index, (index + 2), (index + 4));\n        }\n    }\n\n    /**\n     * Draws the object in triangle mode using canvas\n     *\n     * @private\n     * @param {PIXI.Mesh} mesh - the current mesh\n     */\n    _renderTriangles(mesh)\n    {\n        // draw triangles!!\n        const indices = mesh.geometry.getIndex().data;\n        const length = indices.length;\n\n        for (let i = 0; i < length; i += 3)\n        {\n            // draw some triangles!\n            const index0 = indices[i] * 2;\n            const index1 = indices[i + 1] * 2;\n            const index2 = indices[i + 2] * 2;\n\n            this._renderDrawTriangle(mesh, index0, index1, index2);\n        }\n    }\n\n    /**\n     * Draws one of the triangles that from the Mesh\n     *\n     * @private\n     * @param {PIXI.Mesh} mesh - the current mesh\n     * @param {number} index0 - the index of the first vertex\n     * @param {number} index1 - the index of the second vertex\n     * @param {number} index2 - the index of the third vertex\n     */\n    _renderDrawTriangle(mesh, index0, index1, index2)\n    {\n        const context = this.renderer.context;\n        const vertices = mesh.geometry.buffers[0].data;\n        const { uvs, texture } = mesh;\n\n        if (!texture.valid)\n        {\n            return;\n        }\n\n        const base = texture.baseTexture;\n        const textureSource = base.getDrawableSource();\n        const textureWidth = base.width;\n        const textureHeight = base.height;\n\n        const u0 = uvs[index0] * base.width;\n        const u1 = uvs[index1] * base.width;\n        const u2 = uvs[index2] * base.width;\n        const v0 = uvs[index0 + 1] * base.height;\n        const v1 = uvs[index1 + 1] * base.height;\n        const v2 = uvs[index2 + 1] * base.height;\n\n        let x0 = vertices[index0];\n        let x1 = vertices[index1];\n        let x2 = vertices[index2];\n        let y0 = vertices[index0 + 1];\n        let y1 = vertices[index1 + 1];\n        let y2 = vertices[index2 + 1];\n\n        const canvasPadding = mesh.canvasPadding / this.renderer.resolution;\n\n        if (canvasPadding > 0)\n        {\n            const paddingX = canvasPadding / Math.abs(mesh.worldTransform.a);\n            const paddingY = canvasPadding / Math.abs(mesh.worldTransform.d);\n            const centerX = (x0 + x1 + x2) / 3;\n            const centerY = (y0 + y1 + y2) / 3;\n\n            let normX = x0 - centerX;\n            let normY = y0 - centerY;\n\n            let dist = Math.sqrt((normX * normX) + (normY * normY));\n\n            x0 = centerX + ((normX / dist) * (dist + paddingX));\n            y0 = centerY + ((normY / dist) * (dist + paddingY));\n\n            //\n\n            normX = x1 - centerX;\n            normY = y1 - centerY;\n\n            dist = Math.sqrt((normX * normX) + (normY * normY));\n            x1 = centerX + ((normX / dist) * (dist + paddingX));\n            y1 = centerY + ((normY / dist) * (dist + paddingY));\n\n            normX = x2 - centerX;\n            normY = y2 - centerY;\n\n            dist = Math.sqrt((normX * normX) + (normY * normY));\n            x2 = centerX + ((normX / dist) * (dist + paddingX));\n            y2 = centerY + ((normY / dist) * (dist + paddingY));\n        }\n\n        context.save();\n        context.beginPath();\n\n        context.moveTo(x0, y0);\n        context.lineTo(x1, y1);\n        context.lineTo(x2, y2);\n\n        context.closePath();\n\n        context.clip();\n\n        // Compute matrix transform\n        const delta = (u0 * v1) + (v0 * u2) + (u1 * v2) - (v1 * u2) - (v0 * u1) - (u0 * v2);\n        const deltaA = (x0 * v1) + (v0 * x2) + (x1 * v2) - (v1 * x2) - (v0 * x1) - (x0 * v2);\n        const deltaB = (u0 * x1) + (x0 * u2) + (u1 * x2) - (x1 * u2) - (x0 * u1) - (u0 * x2);\n        const deltaC = (u0 * v1 * x2) + (v0 * x1 * u2) + (x0 * u1 * v2) - (x0 * v1 * u2) - (v0 * u1 * x2) - (u0 * x1 * v2);\n        const deltaD = (y0 * v1) + (v0 * y2) + (y1 * v2) - (v1 * y2) - (v0 * y1) - (y0 * v2);\n        const deltaE = (u0 * y1) + (y0 * u2) + (u1 * y2) - (y1 * u2) - (y0 * u1) - (u0 * y2);\n        const deltaF = (u0 * v1 * y2) + (v0 * y1 * u2) + (y0 * u1 * v2) - (y0 * v1 * u2) - (v0 * u1 * y2) - (u0 * y1 * v2);\n\n        context.transform(\n            deltaA / delta,\n            deltaD / delta,\n            deltaB / delta,\n            deltaE / delta,\n            deltaC / delta,\n            deltaF / delta\n        );\n\n        context.drawImage(\n            textureSource,\n            0,\n            0,\n            textureWidth * base.resolution,\n            textureHeight * base.resolution,\n            0,\n            0,\n            textureWidth,\n            textureHeight\n        );\n\n        context.restore();\n        this.renderer.invalidateBlendMode();\n    }\n\n    /**\n     * Renders a flat Mesh\n     *\n     * @private\n     * @param {PIXI.Mesh} mesh - The Mesh to render\n     */\n    renderMeshFlat(mesh)\n    {\n        const context = this.renderer.context;\n        const vertices = mesh.geometry.getBuffer('aVertexPosition').data;\n        const length = vertices.length / 2;\n\n        // this.count++;\n\n        context.beginPath();\n\n        for (let i = 1; i < length - 2; ++i)\n        {\n            // draw some triangles!\n            const index = i * 2;\n\n            const x0 = vertices[index];\n            const y0 = vertices[index + 1];\n\n            const x1 = vertices[index + 2];\n            const y1 = vertices[index + 3];\n\n            const x2 = vertices[index + 4];\n            const y2 = vertices[index + 5];\n\n            context.moveTo(x0, y0);\n            context.lineTo(x1, y1);\n            context.lineTo(x2, y2);\n        }\n\n        context.fillStyle = '#FF0000';\n        context.fill();\n        context.closePath();\n    }\n\n    /**\n     * destroy the the renderer.\n     *\n     */\n    destroy()\n    {\n        this.renderer = null;\n    }\n}\n","import { settings } from '@pixi/settings';\n\n/**\n * Default `canvasPadding` for canvas-based Mesh rendering.\n *\n * @see PIXI.Mesh2d#canvasPadding\n * @static\n * @name MESH_CANVAS_PADDING\n * @memberof PIXI.settings\n * @type {number}\n * @default 0\n */\nsettings.MESH_CANVAS_PADDING = 0;\n\nexport { settings };\n","import { MeshMaterial } from '@pixi/mesh';\n\n/**\n * Renders the mesh using the Canvas renderer\n *\n * @protected\n * @method render\n * @memberof PIXI.MeshMaterial#\n * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.\n * @param {PIXI.Mesh} mesh - Mesh to render.\n */\nMeshMaterial.prototype._renderCanvas = function _renderCanvas(renderer, mesh)\n{\n    renderer.plugins.mesh.render(mesh);\n};\n","import { canvasUtils } from '@pixi/canvas-renderer';\nimport { NineSlicePlane } from '@pixi/mesh-extras';\n\n/**\n * Cached tint value so we can tell when the tint is changed.\n * @memberof PIXI.NineSlicePlane#\n * @member {number} _cachedTint\n * @protected\n */\nNineSlicePlane.prototype._cachedTint = 0xFFFFFF;\n\n/**\n * Cached tinted texture.\n * @memberof PIXI.NineSlicePlane#\n * @member {HTMLCanvasElement} _tintedCanvas\n * @protected\n */\nNineSlicePlane.prototype._tintedCanvas = null;\n\n/**\n * Temporary storage for canvas source coords\n * @memberof PIXI.NineSlicePlane#\n * @member {number[]} _canvasUvs\n * @private\n */\nNineSlicePlane.prototype._canvasUvs = null;\n\n/**\n * Renders the object using the Canvas renderer\n *\n * @private\n * @method _renderCanvas\n * @memberof PIXI.NineSlicePlane#\n * @param {PIXI.CanvasRenderer} renderer - The canvas renderer to render with.\n */\nNineSlicePlane.prototype._renderCanvas = function _renderCanvas(renderer)\n{\n    const context = renderer.context;\n    const transform = this.worldTransform;\n    const res = renderer.resolution;\n    const isTinted = this.tint !== 0xFFFFFF;\n    const texture = this.texture;\n\n    // Work out tinting\n    if (isTinted)\n    {\n        if (this._cachedTint !== this.tint)\n        {\n            // Tint has changed, need to update the tinted texture and use that instead\n\n            this._cachedTint = this.tint;\n\n            this._tintedCanvas = canvasUtils.getTintedCanvas(this, this.tint);\n        }\n    }\n\n    const textureSource = !isTinted ? texture.baseTexture.getDrawableSource() : this._tintedCanvas;\n\n    if (!this._canvasUvs)\n    {\n        this._canvasUvs = [0, 0, 0, 0, 0, 0, 0, 0];\n    }\n\n    const vertices = this.vertices;\n    const uvs = this._canvasUvs;\n    const u0 = isTinted ? 0 : texture.frame.x;\n    const v0 = isTinted ? 0 : texture.frame.y;\n    const u1 = u0 + texture.frame.width;\n    const v1 = v0 + texture.frame.height;\n\n    uvs[0] = u0;\n    uvs[1] = u0 + this._leftWidth;\n    uvs[2] = u1 - this._rightWidth;\n    uvs[3] = u1;\n    uvs[4] = v0;\n    uvs[5] = v0 + this._topHeight;\n    uvs[6] = v1 - this._bottomHeight;\n    uvs[7] = v1;\n\n    for (let i = 0; i < 8; i++)\n    {\n        uvs[i] *= texture.baseTexture.resolution;\n    }\n\n    context.globalAlpha = this.worldAlpha;\n    renderer.setBlendMode(this.blendMode);\n\n    if (this.roundPixels)\n    {\n        context.setTransform(\n            transform.a * res,\n            transform.b * res,\n            transform.c * res,\n            transform.d * res,\n            (transform.tx * res) | 0,\n            (transform.ty * res) | 0\n        );\n    }\n    else\n    {\n        context.setTransform(\n            transform.a * res,\n            transform.b * res,\n            transform.c * res,\n            transform.d * res,\n            transform.tx * res,\n            transform.ty * res\n        );\n    }\n\n    for (let row = 0; row < 3; row++)\n    {\n        for (let col = 0; col < 3; col++)\n        {\n            const ind = (col * 2) + (row * 8);\n            const sw = Math.max(1, uvs[col + 1] - uvs[col]);\n            const sh = Math.max(1, uvs[row + 5] - uvs[row + 4]);\n            const dw = Math.max(1, vertices[ind + 10] - vertices[ind]);\n            const dh = Math.max(1, vertices[ind + 11] - vertices[ind + 1]);\n\n            context.drawImage(textureSource, uvs[col], uvs[row + 4], sw, sh,\n                vertices[ind], vertices[ind + 1], dw, dh);\n        }\n    }\n};\n","import { Mesh } from '@pixi/mesh';\nimport { settings } from './settings';\n\n/**\n * Renders the object using the Canvas renderer\n *\n * @private\n * @method _renderCanvas\n * @memberof PIXI.Mesh#\n * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.\n */\nMesh.prototype._renderCanvas = function _renderCanvas(renderer)\n{\n    if (this.shader.uvMatrix)\n    {\n        this.shader.uvMatrix.update();\n        this.calculateUvs();\n    }\n\n    this.material._renderCanvas(renderer, this);\n};\n\n// IMPORTANT: Please do NOT use this as a precedent to use `settings` after the object is created\n// this was merely created to completely decouple canvas from the base Mesh class and we are\n// unable to add `canvasPadding` in the constructor anymore, as the case was for PixiJS v4.\n\n/**\n * Internal variable for `canvasPadding`.\n *\n * @private\n * @memberof PIXI.Mesh\n * @member {number}\n * @default null\n */\nMesh.prototype._canvasPadding = null;\n\n/**\n * Triangles in canvas mode are automatically antialiased, use this value to force triangles\n * to overlap a bit with each other. To set the global default, set {@link PIXI.settings.MESH_CANVAS_PADDING}\n *\n * @see PIXI.settings.MESH_CANVAS_PADDING\n * @member {number} canvasPadding\n * @memberof PIXI.SimpleMesh#\n * @default 0\n */\nObject.defineProperty(Mesh.prototype, 'canvasPadding', {\n    get()\n    {\n        return this._canvasPadding !== null ? this._canvasPadding : settings.MESH_CANVAS_PADDING;\n    },\n    set(value)\n    {\n        this._canvasPadding = value;\n    },\n});\n","import { SimpleMesh } from '@pixi/mesh-extras';\n\n/**\n * Renders the object using the Canvas renderer\n *\n * @private\n * @method _renderCanvas\n * @memberof PIXI.Mesh#\n * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.\n */\nSimpleMesh.prototype._renderCanvas = function _renderCanvas(renderer)\n{\n    if (this.autoUpdate)\n    {\n        this.geometry.getBuffer('aVertexPosition').update();\n    }\n\n    if (this.shader.update)\n    {\n        this.shader.update();\n    }\n\n    this.calculateUvs();\n\n    this.material._renderCanvas(renderer, this);\n};\n","import { SimpleRope } from '@pixi/mesh-extras';\n\n/**\n * Renders the object using the Canvas renderer\n *\n * @protected\n * @method _renderCanvas\n * @memberof PIXI.Mesh#\n * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.\n */\nSimpleRope.prototype._renderCanvas = function _renderCanvas(renderer)\n{\n    if (this.autoUpdate\n        || this.geometry.width !== this.shader.texture.height)\n    {\n        this.geometry.width = this.shader.texture.height;\n        this.geometry.update();\n    }\n\n    if (this.shader.update)\n    {\n        this.shader.update();\n    }\n\n    this.calculateUvs();\n\n    this.material._renderCanvas(renderer, this);\n};\n"]},"metadata":{},"sourceType":"module"}